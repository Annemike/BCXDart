# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from piksi_ros/Ephemeris.msg. Do not edit."""
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import piksi_ros.msg
import std_msgs.msg

class Ephemeris(genpy.Message):
  _md5sum = "28a7e20deec95d3746abb19bb2db1355"
  _type = "piksi_ros/Ephemeris"
  _has_header = True #flag to mark the presence of a Header object
  _full_text = """Header header

float64 tgd # Group delay differential between L1 and L2 [s]

float64 c_rs # Amplitude of the sine harmonic correction term to the orbit radius [m]
float64 c_rc # Amplitude of the cosine harmonic correction term to the orbit radius [m]
float64 c_uc # Amplitude of the cosine harmonic correction term to the argument of latitude [rad]
float64 c_us # Amplitude of the sine harmonic correction term to the argument of latitude [rad]
float64 c_ic # Amplitude of the cosine harmonic correction term to the angle of inclination [rad]
float64 c_is # Amplitude of the sine harmonic correction term to the angle of inclination [rad]

float64 dn # Mean motion difference [rad/s]

float64 m0 # Mean anomaly at reference time [rad]

float64 ecc # Eccentricity of satellite orbit
float64 sqrta # Square root of the semi-major axis of orbit [m^(1/2)]

float64 omega0 # Longitude of ascending node of orbit plane at weekly epoch [rad]
float64 omegadot # Rate of right ascension [rad/s]

float64 w # Argument of perigee []

float64 inc # Inclination
float64 inc_dot # Inclination first derivative

float64 af0 # Polynomial clock correction coefficient (clock bias)
float64 af1 # Polynomial clock correction coefficient (clock drift)
float64 af2 # Polynomial clock correction coefficient (rate of clock drift)

float64 toe_tow # Time of week
uint16 toe_wn # Week number

float64 toc_tow # Clock reference time of week
uint16 toc_wn # Clock reference week number

uint8 valid # Is valid?
uint8 healthy # Satellite is healthy?

piksi_ros/Sid sid

uint8 iode # Issue of ephemeris data
uint16 iodc # Issue of clock data

================================================================================
MSG: std_msgs/Header
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data 
# in a particular coordinate frame.
# 
# sequence ID: consecutively increasing ID 
uint32 seq
#Two-integer timestamp that is expressed as:
# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
# time-handling sugar is provided by the client library
time stamp
#Frame this data is associated with
# 0: no frame
# 1: global frame
string frame_id

================================================================================
MSG: piksi_ros/Sid
uint16 sat # Constellation-specific satellite identifier
uint8 band # Signal band
uint8 constellation # Constellation to which the satellite belongs
"""
  __slots__ = ['header','tgd','c_rs','c_rc','c_uc','c_us','c_ic','c_is','dn','m0','ecc','sqrta','omega0','omegadot','w','inc','inc_dot','af0','af1','af2','toe_tow','toe_wn','toc_tow','toc_wn','valid','healthy','sid','iode','iodc']
  _slot_types = ['std_msgs/Header','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','uint16','float64','uint16','uint8','uint8','piksi_ros/Sid','uint8','uint16']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       header,tgd,c_rs,c_rc,c_uc,c_us,c_ic,c_is,dn,m0,ecc,sqrta,omega0,omegadot,w,inc,inc_dot,af0,af1,af2,toe_tow,toe_wn,toc_tow,toc_wn,valid,healthy,sid,iode,iodc

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(Ephemeris, self).__init__(*args, **kwds)
      #message fields cannot be None, assign default values for those that are
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.tgd is None:
        self.tgd = 0.
      if self.c_rs is None:
        self.c_rs = 0.
      if self.c_rc is None:
        self.c_rc = 0.
      if self.c_uc is None:
        self.c_uc = 0.
      if self.c_us is None:
        self.c_us = 0.
      if self.c_ic is None:
        self.c_ic = 0.
      if self.c_is is None:
        self.c_is = 0.
      if self.dn is None:
        self.dn = 0.
      if self.m0 is None:
        self.m0 = 0.
      if self.ecc is None:
        self.ecc = 0.
      if self.sqrta is None:
        self.sqrta = 0.
      if self.omega0 is None:
        self.omega0 = 0.
      if self.omegadot is None:
        self.omegadot = 0.
      if self.w is None:
        self.w = 0.
      if self.inc is None:
        self.inc = 0.
      if self.inc_dot is None:
        self.inc_dot = 0.
      if self.af0 is None:
        self.af0 = 0.
      if self.af1 is None:
        self.af1 = 0.
      if self.af2 is None:
        self.af2 = 0.
      if self.toe_tow is None:
        self.toe_tow = 0.
      if self.toe_wn is None:
        self.toe_wn = 0
      if self.toc_tow is None:
        self.toc_tow = 0.
      if self.toc_wn is None:
        self.toc_wn = 0
      if self.valid is None:
        self.valid = 0
      if self.healthy is None:
        self.healthy = 0
      if self.sid is None:
        self.sid = piksi_ros.msg.Sid()
      if self.iode is None:
        self.iode = 0
      if self.iodc is None:
        self.iodc = 0
    else:
      self.header = std_msgs.msg.Header()
      self.tgd = 0.
      self.c_rs = 0.
      self.c_rc = 0.
      self.c_uc = 0.
      self.c_us = 0.
      self.c_ic = 0.
      self.c_is = 0.
      self.dn = 0.
      self.m0 = 0.
      self.ecc = 0.
      self.sqrta = 0.
      self.omega0 = 0.
      self.omegadot = 0.
      self.w = 0.
      self.inc = 0.
      self.inc_dot = 0.
      self.af0 = 0.
      self.af1 = 0.
      self.af2 = 0.
      self.toe_tow = 0.
      self.toe_wn = 0
      self.toc_tow = 0.
      self.toc_wn = 0
      self.valid = 0
      self.healthy = 0
      self.sid = piksi_ros.msg.Sid()
      self.iode = 0
      self.iodc = 0

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_get_struct_3I().pack(_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs))
      _x = self.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_get_struct_20dHdH2BH3BH().pack(_x.tgd, _x.c_rs, _x.c_rc, _x.c_uc, _x.c_us, _x.c_ic, _x.c_is, _x.dn, _x.m0, _x.ecc, _x.sqrta, _x.omega0, _x.omegadot, _x.w, _x.inc, _x.inc_dot, _x.af0, _x.af1, _x.af2, _x.toe_tow, _x.toe_wn, _x.toc_tow, _x.toc_wn, _x.valid, _x.healthy, _x.sid.sat, _x.sid.band, _x.sid.constellation, _x.iode, _x.iodc))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    try:
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.sid is None:
        self.sid = piksi_ros.msg.Sid()
      end = 0
      _x = self
      start = end
      end += 12
      (_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs,) = _get_struct_3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.header.frame_id = str[start:end].decode('utf-8')
      else:
        self.header.frame_id = str[start:end]
      _x = self
      start = end
      end += 181
      (_x.tgd, _x.c_rs, _x.c_rc, _x.c_uc, _x.c_us, _x.c_ic, _x.c_is, _x.dn, _x.m0, _x.ecc, _x.sqrta, _x.omega0, _x.omegadot, _x.w, _x.inc, _x.inc_dot, _x.af0, _x.af1, _x.af2, _x.toe_tow, _x.toe_wn, _x.toc_tow, _x.toc_wn, _x.valid, _x.healthy, _x.sid.sat, _x.sid.band, _x.sid.constellation, _x.iode, _x.iodc,) = _get_struct_20dHdH2BH3BH().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e) #most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_get_struct_3I().pack(_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs))
      _x = self.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_get_struct_20dHdH2BH3BH().pack(_x.tgd, _x.c_rs, _x.c_rc, _x.c_uc, _x.c_us, _x.c_ic, _x.c_is, _x.dn, _x.m0, _x.ecc, _x.sqrta, _x.omega0, _x.omegadot, _x.w, _x.inc, _x.inc_dot, _x.af0, _x.af1, _x.af2, _x.toe_tow, _x.toe_wn, _x.toc_tow, _x.toc_wn, _x.valid, _x.healthy, _x.sid.sat, _x.sid.band, _x.sid.constellation, _x.iode, _x.iodc))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    try:
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.sid is None:
        self.sid = piksi_ros.msg.Sid()
      end = 0
      _x = self
      start = end
      end += 12
      (_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs,) = _get_struct_3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.header.frame_id = str[start:end].decode('utf-8')
      else:
        self.header.frame_id = str[start:end]
      _x = self
      start = end
      end += 181
      (_x.tgd, _x.c_rs, _x.c_rc, _x.c_uc, _x.c_us, _x.c_ic, _x.c_is, _x.dn, _x.m0, _x.ecc, _x.sqrta, _x.omega0, _x.omegadot, _x.w, _x.inc, _x.inc_dot, _x.af0, _x.af1, _x.af2, _x.toe_tow, _x.toe_wn, _x.toc_tow, _x.toc_wn, _x.valid, _x.healthy, _x.sid.sat, _x.sid.band, _x.sid.constellation, _x.iode, _x.iodc,) = _get_struct_20dHdH2BH3BH().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e) #most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_3I = None
def _get_struct_3I():
    global _struct_3I
    if _struct_3I is None:
        _struct_3I = struct.Struct("<3I")
    return _struct_3I
_struct_20dHdH2BH3BH = None
def _get_struct_20dHdH2BH3BH():
    global _struct_20dHdH2BH3BH
    if _struct_20dHdH2BH3BH is None:
        _struct_20dHdH2BH3BH = struct.Struct("<20dHdH2BH3BH")
    return _struct_20dHdH2BH3BH
